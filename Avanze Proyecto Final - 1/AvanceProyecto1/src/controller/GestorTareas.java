package controller;

import java.io.IOException;
import model.Nodo;
import org.apache.pdfbox.pdmodel.*;
import org.apache.pdfbox.pdmodel.font.PDType1Font;
import org.apache.pdfbox.pdmodel.common.PDRectangle;
import org.apache.pdfbox.pdmodel.PDPageContentStream;
/* Importamos para exportar a PDF*/
import model.ListaEnlazada;
import model.Tarea;
import model.Nodo;
import clases.ValidadorTareas;
import clases.Prioridad;
import org.apache.pdfbox.pdmodel.font.Standard14Fonts;
import org.apache.pdfbox.pdmodel.font.PDType1Font;
import org.apache.pdfbox.pdmodel.font.PDType0Font;
import java.io.File;
import java.util.Scanner;
/* Importamos las clases adicionales para los CRUD */
import java.io.FileWriter;
import java.io.FileReader;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.IOException;
/* Importamos para el logo */
import org.apache.pdfbox.pdmodel.graphics.image.PDImageXObject;
import java.awt.image.BufferedImage;
import javax.imageio.ImageIO;
import java.io.File;
/* Importamos para la fecha */
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

/**
 * Clase que gestiona las operaciones del sistema de tareas pendientes. Permite
 * agregar, listar, buscar y eliminar tareas, adem√°s de validar datos de
 * entrada.
 *
 * @author daniel
 */
public class GestorTareas {

    private ListaEnlazada lista; // Lista enlazada para almacenar las tareas
    private ListaEnlazada historialTareas; // Lista para almacenar las tareas completadas
    private Scanner scanner = new Scanner(System.in); // Scanner para la entrada de datos del usuario

    /**
     * Constructor que inicializa la lista enlazada para gestionar las tareas.
     */
    public GestorTareas() {
        lista = new ListaEnlazada();
        historialTareas = new ListaEnlazada(); // Inicializamos la lista de historial
    }

    /**
     * M√©todo para agregar una nueva tarea con validaci√≥n de datos.
     *
     * @param descripcion Descripci√≥n de la tarea.
     * @param prioridad Nivel de prioridad de la tarea (Alta, Media, Baja).
     */
    public void agregarTarea(String descripcion, String prioridad) {
        imprimirLineaDecorativa();
        if (!ValidadorTareas.validarDescripcion(descripcion)) {
            System.out.println("‚ö†Ô∏è  La descripci√≥n de la tarea no puede estar vac√≠a.");
            pausar();
            return;
        }
        if (!ValidadorTareas.validarPrioridad(prioridad)) {
            System.out.println("‚ö†Ô∏è  Prioridad no v√°lida. Debe ser Alta, Media o Baja.");
            pausar();
            return;
        }
        lista.agregar(new Tarea(descripcion, prioridad));
        System.out.println("‚úÖ Tarea agregada exitosamente.");
        imprimirLineaDecorativa();

        exportarTareasATxt(); // üîπ Se exporta autom√°ticamente despu√©s de agregar una tarea
        pausar();
    }

    /**
     * M√©todo para listar todas las tareas pendientes almacenadas en la lista
     * enlazada.
     */
    public void listarTareas() {
        imprimirLineaDecorativa();
        lista.listarTareas();
        imprimirLineaDecorativa();
        pausar();
    }

    /**
     * M√©todo para completar (eliminar) una tarea de la lista. Si la tarea no se
     * encuentra, sugiere tareas similares.
     *
     * @param descripcion Descripci√≥n de la tarea a eliminar.
     */
    public void completarTarea(String descripcion) {
        Tarea tarea = lista.buscarTarea(descripcion);
        if (tarea != null && tarea.getEstado().equals("En Progreso")) {
            tarea.setEstado("Completada");
            lista.eliminarTarea(tarea.getDescripcion());
            historialTareas.agregar(tarea);
            System.out.println("‚úÖ Tarea completada y movida al historial: " + tarea.getDescripcion());

            exportarTareasATxt(); // üîπ Se exporta autom√°ticamente despu√©s de completar una tarea
        } else {
            System.out.println("‚ùå Solo se pueden completar tareas que est√°n en progreso.");
        }
    }

    private void agregarMarcaDeAgua(PDPageContentStream contentStream, PDPage page, PDType0Font font, String texto) throws IOException {
        contentStream.setFont(font, 14); // üîπ Reducimos tama√±o para que no sea invasivo

        // üîπ Color gris claro para que se vea como una marca de agua discreta
        contentStream.setNonStrokingColor(0.6f, 0.6f, 0.6f); // üîπ Un poco m√°s oscuro para que sea visible

        // üîπ Posicionar el footer en la parte inferior de la p√°gina
        float pageWidth = page.getMediaBox().getWidth();
        float posY = 30; // üîπ Asegura que est√© cerca del borde inferior

        contentStream.beginText();
        contentStream.newLineAtOffset(pageWidth / 3, posY); // üîπ Centrar horizontalmente
        contentStream.showText(texto);
        contentStream.endText();

        // üîπ Restaurar el color del texto a negro para evitar afectar el contenido
        contentStream.setNonStrokingColor(0, 0, 0);
    }

    private void agregarFooter(PDPageContentStream contentStream, PDPage page, PDType0Font font) throws IOException {
        contentStream.setFont(font, 12); // üîπ Tama√±o del texto en el footer
        contentStream.setNonStrokingColor(0.6f, 0.6f, 0.6f); // üîπ Color gris claro

        // üîπ Obtener la fecha y hora actual
        LocalDateTime ahora = LocalDateTime.now();
        DateTimeFormatter formato = DateTimeFormatter.ofPattern("dd/MM/yyyy HH:mm:ss");
        String fechaHora = ahora.format(formato);

        // üîπ Texto del footer con fecha y hora
        String texto = "Proyecto hecho por Daniel Esteban Huaman Lazaro - " + fechaHora;

        // üîπ Obtener el ancho de la p√°gina
        float pageWidth = page.getMediaBox().getWidth();
        float posY = 30; // üîπ Posici√≥n cerca del borde inferior

        // üîπ Medir el ancho del texto para centrarlo
        float textWidth = font.getStringWidth(texto) / 1000 * 12; // Escalar la fuente correctamente

        // üîπ Calcular la posici√≥n X para que el texto quede centrado
        float posX = (pageWidth - textWidth) / 2;

        contentStream.beginText();
        contentStream.newLineAtOffset(posX, posY); // üîπ Ahora estar√° completamente centrado
        contentStream.showText(texto);
        contentStream.endText();

        // üîπ Restaurar el color del texto a negro para evitar afectar el contenido
        contentStream.setNonStrokingColor(0, 0, 0);
    }

    public void exportarTareasAPdf() {
        String nombreArchivo = "tareas_exportadas.pdf";
        File archivo = new File(nombreArchivo);

        // Elimina el archivo si ya existe
        if (archivo.exists()) {
            archivo.delete();
        }

        try (PDDocument document = new PDDocument()) {
            PDPage page = new PDPage(PDRectangle.A4);
            document.addPage(page);

            PDType0Font font = PDType0Font.load(document, new File("fonts/NotoSans-Regular.ttf"));

            try (PDPageContentStream contentStream = new PDPageContentStream(document, page, PDPageContentStream.AppendMode.OVERWRITE, true, true)) {

                // üîπ Dibujar el encabezado de color en la parte superior
                float headerHeight = 50;
                contentStream.setNonStrokingColor(173 / 255f, 216 / 255f, 230 / 255f); // üîπ Color azul claro
                contentStream.addRect(0, page.getMediaBox().getHeight() - headerHeight, page.getMediaBox().getWidth(), headerHeight);
                contentStream.fill();

                // üîπ Restaurar color a negro
                contentStream.setNonStrokingColor(0, 0, 0);

                // üîπ Cargar y colocar el logo dentro del encabezado
                PDImageXObject logo = PDImageXObject.createFromFile("src/resources/logo2.png", document);
                float logoWidth = 40;  // üîπ Ajustar tama√±o del logo
                float logoHeight = 40;
                float logoX = page.getMediaBox().getWidth() - logoWidth - 10; // üîπ Posici√≥n en la esquina derecha
                float logoY = page.getMediaBox().getHeight() - logoHeight - 5;
                contentStream.drawImage(logo, logoX, logoY, logoWidth, logoHeight);

                // üîπ Agregar el t√≠tulo "Gesti√≥n de Tareas" en el encabezado
                contentStream.setFont(font, 14);
                contentStream.beginText();
                contentStream.newLineAtOffset(20, page.getMediaBox().getHeight() - 30); // üîπ Posici√≥n en la izquierda
                contentStream.showText("Sistema de Gesti√≥n de Tareas Pendientes");
                contentStream.endText();

                // üîπ Agregar el contenido despu√©s del encabezado
                int y = 700;
                y = escribirTareasEnPdf(contentStream, "Tareas Pendientes:", "Pendiente", y, font);
                y = escribirTareasEnPdf(contentStream, "Tareas en Progreso:", "En Progreso", y, font);
                y = escribirTareasEnPdf(contentStream, "Tareas Completadas:", "Completada", y, font);

                // üîπ Agregar el footer con "Proyecto hecho por Daniel Huaman"
                agregarFooter(contentStream, page, font);
            }

            document.save(nombreArchivo);
            System.out.println("‚úÖ PDF exportado correctamente con encabezado, logo y footer: " + nombreArchivo);
        } catch (IOException e) {
            System.out.println("‚ùå Error al exportar a PDF: " + e.getMessage());
        }
    }

    public void mostrarHistorialTareas() {
        imprimirLineaDecorativa();
        System.out.println("üìú Historial de Tareas Completadas:");
        if (historialTareas.getCabeza() == null) {
            System.out.println("üìå No hay tareas completadas a√∫n.");
        } else {
            Nodo actual = historialTareas.getCabeza();
            while (actual != null) {
                System.out.println("‚úîÔ∏è " + actual.tarea.getDescripcion() + " | ‚è´ Prioridad: " + actual.tarea.getPrioridad());
                actual = actual.siguiente;
            }
        }
        imprimirLineaDecorativa();
        pausar();
    }

    public void exportarTareasATxt() {
        String nombreArchivo = "tareas_exportadas.txt";

        System.out.println("üìÇ Exportando tareas a: " + nombreArchivo);

        try (PrintWriter writer = new PrintWriter(new FileWriter(nombreArchivo))) {
            writer.println("=== Lista de Tareas ===\n");

            // Guardar tareas pendientes
            writer.println("üìå Tareas Pendientes:");
            guardarTareasPorEstado(writer, "Pendiente");

            // Guardar tareas en progreso
            writer.println("\n‚è≥ Tareas en Progreso:");
            guardarTareasPorEstado(writer, "En Progreso");

            // Guardar tareas completadas
            writer.println("\n‚úÖ Tareas Completadas:");
            guardarTareasPorEstado(writer, "Completada");

            System.out.println("‚úÖ Tareas exportadas correctamente.");
        } catch (IOException e) {
            System.out.println("‚ùå Error al exportar tareas: " + e.getMessage());
        }
    }

    /**
     * M√©todo auxiliar para escribir tareas de un estado espec√≠fico en el
     * archivo.
     */
    private void guardarTareasPorEstado(PrintWriter writer, String estado) {
        Nodo actual = lista.getCabeza();
        boolean hayTareas = false;

        while (actual != null) {
            if (actual.tarea.getEstado().equals(estado)) {
                String tareaTexto = "üìã " + actual.tarea.getDescripcion() + " | Prioridad: " + actual.tarea.getPrioridad();
                writer.println(tareaTexto);
                System.out.println("üìù Guardando tarea: " + tareaTexto); // Depuraci√≥n
                hayTareas = true;
            }
            actual = actual.siguiente;
        }

        if (!hayTareas) {
            writer.println("üì≠ No hay tareas en este estado.");
        }
    }

    /**
     * M√©todo auxiliar para escribir y mostrar tareas de un estado espec√≠fico.
     */
    private void guardarTareasPorEstado(PrintWriter writer, String estado, boolean mostrarEnConsola) {
        Nodo actual = lista.getCabeza();
        boolean hayTareas = false;

        while (actual != null) {
            if (actual.tarea.getEstado().equals(estado)) {
                String tareaTexto = "üìã " + actual.tarea.getDescripcion() + " | Prioridad: " + actual.tarea.getPrioridad();
                writer.println(tareaTexto);
                if (mostrarEnConsola) {
                    System.out.println(tareaTexto);
                }
                hayTareas = true;
            }
            actual = actual.siguiente;
        }

        if (!hayTareas) {
            writer.println("üì≠ No hay tareas en este estado.");
            if (mostrarEnConsola) {
                System.out.println("üì≠ No hay tareas en este estado.");
            }
        }
    }

    private String eliminarEmojis(String texto) {
        return texto.replaceAll("[^\\p{ASCII}]", ""); // üîπ Elimina cualquier car√°cter fuera del est√°ndar ASCII
    }

    /**
     * M√©todo auxiliar escribe las tareas dentro del PDF en la posici√≥n
     * correcta.
     */
    private int escribirTareasEnPdf(PDPageContentStream contentStream, String titulo, String estado, int startY, PDType0Font font) throws IOException {
        contentStream.setFont(font, 14); // Tama√±o de fuente mayor
        int y = startY;

        // Escribir el t√≠tulo de la secci√≥n
        contentStream.beginText();
        contentStream.newLineAtOffset(100, y);
        contentStream.showText(eliminarEmojis(titulo));
        contentStream.endText();

        y -= 40; // Espacio despu√©s del t√≠tulo

        boolean hayTareas = false;
        Nodo actual = lista.getCabeza();
        while (actual != null) {
            if (actual.tarea.getEstado().equals(estado)) {
                hayTareas = true;
                String descripcionLimpia = eliminarEmojis(actual.tarea.getDescripcion());
                String prioridadLimpia = eliminarEmojis(actual.tarea.getPrioridad());

                contentStream.beginText();
                contentStream.newLineAtOffset(120, y);
                contentStream.showText(descripcionLimpia + " | Prioridad: " + prioridadLimpia);
                contentStream.endText();

                y -= 30; // Espaciado entre cada tarea
            }
            actual = actual.siguiente;
        }

        if (!hayTareas) {
            contentStream.beginText();
            contentStream.newLineAtOffset(120, y);
            contentStream.showText("No hay tareas en este estado.");
            contentStream.endText();
            y -= 30;
        }

        y -= 50; // Espacio extra antes de la siguiente secci√≥n
        return y;
    }

    public void cargarTareasDesdeTxt() {
        String nombreArchivo = "tareas_exportadas.txt";

        System.out.println("üìÇ Intentando cargar tareas desde: " + nombreArchivo);

        try (BufferedReader reader = new BufferedReader(new FileReader(nombreArchivo))) {
            String linea;
            String estadoActual = ""; // Almacena en qu√© secci√≥n del archivo estamos leyendo

            while ((linea = reader.readLine()) != null) {
                System.out.println("üîç Leyendo l√≠nea: " + linea); // Depuraci√≥n

                if (linea.startsWith("üìå Tareas Pendientes:")) {
                    estadoActual = "Pendiente";
                } else if (linea.startsWith("‚è≥ Tareas en Progreso:")) {
                    estadoActual = "En Progreso";
                } else if (linea.startsWith("‚úÖ Tareas Completadas:")) {
                    estadoActual = "Completada";
                } else if (linea.startsWith("üìã")) { // Detectar l√≠neas con tareas
                    String[] partes = linea.split("\\|"); // Separar descripci√≥n y prioridad

                    if (partes.length == 2) {
                        String descripcion = partes[0].replace("üìã", "").trim();
                        String prioridad = partes[1].replace("Prioridad:", "").trim();

                        Tarea tarea = new Tarea(descripcion, prioridad);
                        tarea.setEstado(estadoActual); // üîπ Establecemos el estado correcto

                        // üîπ Agregar la tarea a la lista correspondiente
                        if (estadoActual.equals("Pendiente") || estadoActual.equals("En Progreso")) {
                            lista.agregar(tarea);
                            System.out.println("‚úÖ Tarea agregada: " + descripcion + " | " + prioridad);
                        } else if (estadoActual.equals("Completada")) {
                            historialTareas.agregar(tarea);
                            System.out.println("‚úÖ Tarea completada agregada al historial: " + descripcion);
                        }
                    }
                }
            }
            System.out.println("‚úÖ Tareas cargadas desde el archivo.");
        } catch (IOException e) {
            System.out.println("‚ö†Ô∏è  No se encontr√≥ el archivo. Se iniciar√° con una lista vac√≠a.");
        }
    }

    /**
     * M√©todo privado para sugerir tareas similares si no se encuentra una
     * coincidencia exacta.
     *
     * @param descripcion Descripci√≥n de la tarea buscada.
     */
    private void sugerirTareasSimilares(String descripcion) {
        System.out.println("üîç ¬øQuiz√°s quisiste decir?");
        Nodo actual = lista.getCabeza();
        boolean encontrado = false;
        while (actual != null) {
            if (actual.tarea.getDescripcion().toLowerCase().contains(descripcion.toLowerCase())) {
                System.out.println("- " + actual.tarea.getDescripcion() + " | Prioridad: " + actual.tarea.getPrioridad());
                encontrado = true;
            }
            actual = actual.siguiente;
        }
        if (!encontrado) {
            System.out.println("‚ùó No se encontraron tareas similares.");
        }
    }

    public void mostrarTareasPorEstado() {
        System.out.println("üìå Tareas Pendientes:");
        mostrarPorEstado("Pendiente");
        System.out.println("\n‚è≥ Tareas en Progreso:");
        mostrarPorEstado("En Progreso");
        System.out.println("\n‚úÖ Tareas Completadas:");
        mostrarPorEstado("Completada");
    }

    private void mostrarPorEstado(String estado) {
        Nodo actual = lista.getCabeza();
        boolean hayTareas = false;
        while (actual != null) {
            if (actual.tarea.getEstado().equals(estado)) {
                System.out.println("üìã " + actual.tarea.getDescripcion() + " | Prioridad: " + actual.tarea.getPrioridad());
                hayTareas = true;
            }
            actual = actual.siguiente;
        }
        if (!hayTareas) {
            System.out.println("üì≠ No hay tareas en este estado.");
        }
    }

    /**
     * M√©todo para buscar una tarea por su descripci√≥n. Si no se encuentra,
     * sugiere tareas similares.
     *
     * @param descripcion Descripci√≥n de la tarea a buscar.
     */
    public void buscarTarea(String descripcion) {
        imprimirLineaDecorativa();
        Tarea tarea = lista.buscarTarea(descripcion);
        if (tarea != null) {
            System.out.println("üîé Tarea encontrada:");
            System.out.println("üìã " + tarea.getDescripcion() + " | ‚è´ Prioridad: " + tarea.getPrioridad());
        } else {
            System.out.println("‚ùå Tarea no encontrada.");
            sugerirTareasSimilares(descripcion);
        }
        imprimirLineaDecorativa();
        pausar();
    }

    public void moverTareaAEnProgreso(String descripcion) {
        Tarea tarea = lista.buscarTarea(descripcion);
        if (tarea != null && tarea.getEstado().equals("Pendiente")) {
            tarea.setEstado("En Progreso");
            System.out.println("üîÑ Tarea ahora est√° en progreso: " + tarea.getDescripcion());

            exportarTareasATxt(); // üîπ Se exporta autom√°ticamente despu√©s de mover una tarea
        } else {
            System.out.println("‚ùå No se encontr√≥ una tarea pendiente con esa descripci√≥n.");
        }
    }

    /**
     * M√©todo para imprimir una l√≠nea decorativa que separa las secciones de la
     * interfaz.
     */
    private void imprimirLineaDecorativa() {
        System.out.println("=====================================");
    }

    /**
     * M√©todo para pausar la ejecuci√≥n y esperar que el usuario presione Enter
     * para continuar.
     */
    private void pausar() {
        System.out.println("Presiona Enter para continuar...");
        scanner.nextLine();
        limpiarPantalla();
    }

    /**
     * M√©todo para simular la limpieza de pantalla mediante saltos de l√≠nea.
     */
    private void limpiarPantalla() {
        for (int i = 0; i < 10; i++) {
            System.out.println();
        }
    }

    /**
     * M√©todo para mostrar √∫nicamente las tareas pendientes sin pausas ni
     * decoraciones.
     */
    public void mostrarTareasPendientes() {
        Nodo actual = lista.getCabeza();
        if (actual == null) {
            System.out.println("üìå No hay tareas pendientes.");
            return;
        }
        while (actual != null) {
            System.out.println("üìã " + actual.tarea.getDescripcion() + " | ‚è´ Prioridad: " + actual.tarea.getPrioridad());
            actual = actual.siguiente;
        }
    }

}
